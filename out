
 Show LEARNING :: true
 Show Bidirectional :: true
 specfile :: synth_tests/unit/checked/tbl/test.spectbl : ref [int];
Tbl' : [int];
Tbl :  [int];
num : ref int;



create_pair : (x : {v : char | true}) -> 
				(y: {v : float | true}) -> 
                {v : pair | true};




fresh_str : State 
			{\(h : heap). not (sel (h, num) > 2)} 
			v : { v : int | true} 
			{\(h : heap), (v : int), (h' : heap). 
				\(Tbl' : [int]).
				sel (h', num) == sel (h, num) + 1 /\
				ilssel (h', tbl) = Tbl' /\  
				ilssel (h', tbl) = ilssel (h, tbl) /\
				mem (Tbl', v) = false};




add : (s : {v : int | true}) ->  
			State  {\(h : heap).
				\(Tbl : [int]). 
				ilssel (h, tbl) = Tbl =>  
				(mem (Tbl, s) = false)} 
				v : { v : unit | true} 
			{\(h : heap), (v : unit), (h' : heap). 
				\(Tbl' : [int]), (Tbl : [int]).
				ilssel (h', tbl) = Tbl'/\
				ilssel (h, tbl) = Tbl /\
				mem (Tbl', s) = true /\
				size (Tbl') == size (Tbl) + 1 /\
				sel (h', num) == sel (h, num) 
				};




goal : (s : {v : int | true}) -> 
		State {\(h : heap). 
			 \(Tbl : [int]). 
				sel (h, num) == 0 /\
				ilssel (h, tbl) = Tbl /\
				not  (0 > size (Tbl)) /\
				(mem (Tbl, s) = true)}
				v : {v : pair | true}
		  	{\(h : heap), (v : pair), (h' : heap). 
				\(Tbl' : [int]), (Tbl : [int]).
				(ilssel (h, tbl) = Tbl /\  
				ilssel (h', tbl) = Tbl')   
				=> 
				size (Tbl') == size (Tbl) + 2 
				
			};

var: tbl
whitespace colon
whitespace refwhitespace lbrace
var: int
rbrace
semicolon
var: Tbl'
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: Tbl
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: num
whitespace colon
whitespace refwhitespace var: int
semicolon
var: create_pair
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: char
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: y
colon
whitespace lcurly
var: v
whitespace colon
whitespace var: float
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: pair
whitespace pipe
whitespace truercurly
semicolon
var: fresh_str
whitespace colon
whitespace var: State
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: num
rparen
whitespace lessthanopwhitespace int: 2
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace lambdalparen
var: Tbl'
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: num
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: num
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: ilssel
whitespace lparen
var: h'
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl'
whitespace conjwhitespace whitespace var: ilssel
whitespace lparen
var: h'
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: ilssel
whitespace lparen
var: h
comma
whitespace var: tbl
rparen
whitespace conjwhitespace var: mem
whitespace lparen
var: Tbl'
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: add
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace lambdalparen
var: Tbl
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace whitespace var: ilssel
whitespace lparen
var: h
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl
whitespace implieswhitespace whitespace lparen
var: mem
whitespace lparen
var: Tbl
comma
whitespace var: s
rparen
whitespace equalopwhitespace falserparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: unit
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: unit
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace lambdalparen
var: Tbl'
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: Tbl
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: ilssel
whitespace lparen
var: h'
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl'
conjwhitespace var: ilssel
whitespace lparen
var: h
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl
whitespace conjwhitespace var: mem
whitespace lparen
var: Tbl'
comma
whitespace var: s
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: size
whitespace lparen
var: Tbl'
rparen
whitespace equalopwhitespace var: size
whitespace lparen
var: Tbl
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: num
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: num
rparen
whitespace whitespace rcurly
semicolon
var: goal
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace lambdalparen
var: Tbl
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h
comma
whitespace var: num
rparen
whitespace equalopwhitespace int: 0
whitespace conjwhitespace var: ilssel
whitespace lparen
var: h
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl
whitespace conjwhitespace notwhitespace lparen
int: 0
whitespace lessthanopwhitespace var: size
whitespace lparen
var: Tbl
rparen
rparen
whitespace conjwhitespace lparen
var: mem
whitespace lparen
var: Tbl
comma
whitespace var: s
rparen
whitespace equalopwhitespace truerparen
rcurly
whitespace var: v
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: pair
whitespace pipe
whitespace truercurly
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: pair
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace lambdalparen
var: Tbl'
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: Tbl
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: ilssel
whitespace lparen
var: h
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl
whitespace conjwhitespace whitespace var: ilssel
whitespace lparen
var: h'
comma
whitespace var: tbl
rparen
whitespace equalopwhitespace var: Tbl'
rparen
whitespace whitespace implieswhitespace whitespace var: size
whitespace lparen
var: Tbl'
rparen
whitespace equalopwhitespace var: size
whitespace lparen
var: Tbl
rparen
whitespace pluswhitespace int: 2
whitespace whitespace whitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name tbl : 
 params :
 Type Base {var_v0:Ty_ref Ty_list Ty_int | true} 
 Assume false
 name Tbl' : 
 params :
 Type Base {var_v1:Ty_list Ty_int | true} 
 Assume false
 name Tbl : 
 params :
 Type Base {var_v2:Ty_list Ty_int | true} 
 Assume false
 name num : 
 params :
 Type Base {var_v3:Ty_ref Ty_int | true} 
 Assume false
 name create_pair : 
 params :
 Type  Arrow ( ( x , Base {v:Ty_char | true} ), Arrow ( ( y , Base {v:Ty_float | true} ),Base {v:Ty_alphapair | true} 
 Assume false
 name fresh_str : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Negation (sel)( , h, num ) > (2) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h', num ) ==((sel)( , h, num ) + (1))
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (ilssel)( , h, tbl )
 	 , (mem)( , Tbl', v ) = (false) >c  >c  >c  } } 
 } 
 ) 
 Assume false
 name add : 
 params :
 Type  Arrow ( ( s , Base {v:Ty_int | true} ),MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < (ilssel)( , h, tbl ) = (Tbl)
 	 (mem)( , Tbl, s ) = (false) > } } 
 } 
 
                                                RET :  Base {v:Ty_unit | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_unit
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c (mem)( , Tbl', s ) = (true)
 	 , 
 	 Conj <c (size)(Tbl') ==((size)(Tbl) + (1))
 	 , (sel)( , h', num ) ==(sel)( , h, num ) >c  >c  >c  >c  } } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( s , Base {v:Ty_int | true} ),MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  } } 
 } 
 
                                                RET :  Base {v:Ty_alphapair | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_alphapair
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } } 
 } 
 );  Formulas  } INITIAL GAMMA 
 
 add :  Arrow ( ( s , Base {v:Ty_int | true} ),MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < (ilssel)( , h, tbl ) = (Tbl)
 	 (mem)( , Tbl, s ) = (false) > } } 
 } 
 
                                                RET :  Base {v:Ty_unit | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_unit
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c (mem)( , Tbl', s ) = (true)
 	 , 
 	 Conj <c (size)(Tbl') ==((size)(Tbl) + (1))
 	 , (sel)( , h', num ) ==(sel)( , h, num ) >c  >c  >c  >c  } } 
 } 
 )
 fresh_str : MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Negation (sel)( , h, num ) > (2) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h', num ) ==((sel)( , h, num ) + (1))
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (ilssel)( , h, tbl )
 	 , (mem)( , Tbl', v ) = (false) >c  >c  >c  } } 
 } 
 )
 create_pair :  Arrow ( ( x , Base {v:Ty_char | true} ), Arrow ( ( y , Base {v:Ty_float | true} ),Base {v:Ty_alphapair | true}
 num : Base {var_v3:Ty_ref Ty_int | true}
 Tbl : Base {var_v2:Ty_list Ty_int | true}
 Tbl' : Base {var_v1:Ty_list Ty_int | true}
 tbl : Base {var_v0:Ty_ref Ty_list Ty_int | true} INITIAL SIGMA 
 
Show ***********Calling S-FUNC synthesize***************
Show Uncurried , s:Base {v:Ty_int | true} -> MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  } } 
 } 
 
                                                RET :  Base {v:Ty_alphapair | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_alphapair
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } } 
 } 
 )
Show Trying :: Top-level Match
Show :: Synthesize Match MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  } } 
 } 
 
                                                RET :  Base {v:Ty_alphapair | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_alphapair
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } } 
 } 
 )
Show :: List Ty_int
Show :: Non List Case
Show ::::::::: Match-case failed :: Try Top-level If then else 
Show ::::::::::::::: iSynthesize If THEN ELSE MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  } } 
 } 
 
                                                RET :  Base {v:Ty_alphapair | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_alphapair
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } } 
 } 
 )
Show :: iSynthesize Boolean Base {var_v4:Ty_bool | true}
Show :: esynthesizeScalar for Base {var_v4:Ty_bool | true}
Show :: No Scalar found, Call esynthesizePureApp 
Show :: In esynthesizePureApp 
Show Potential Functions
 
Show :: No pureApp found, Call esynthesizeConsApp 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
 Show :: Failed to find a Pure Boolean Function App, Now looking for Effectful Bool Function
 Type Constructed MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h5 Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v4:Ty_bool | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h5 Value = Ty_heap
 Key =var_v4 Value = Ty_bool
 Key =var_h'6 Value = Ty_heap{ true } 
 } 
 )
Show ***********Calling  BIDI- for MArrow/Uncurried synthesize***************
 %%%%%%%%%%%% Uncurried  -> MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h5 Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v4:Ty_bool | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h5 Value = Ty_heap
 Key =var_v4 Value = Ty_bool
 Key =var_h'6 Value = Ty_heap{ true } 
 } 
 )
Show ***********Bidirection FALSE : Calling CDCL***************
Show :: in CDCL :: GOAL MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h5 Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v4:Ty_bool | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h5 Value = Ty_heap
 Key =var_v4 Value = Ty_bool
 Key =var_h'6 Value = Ty_heap{ true } 
 } 
 )
 EXPLORED :: pp-path 

CHOOSING FROM 
Choice 
Show :: Failed EffBool
Show >>>>>>>>>>>>>>>>>>>>>> If then else Failed :: Try CDCL without subdivision
 <<<<<<<<<<<<<<<<<<<
Show ***********Calling  BIDI- for MArrow/Uncurried synthesize***************
 %%%%%%%%%%%% Uncurried  -> MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  } } 
 } 
 
                                                RET :  Base {v:Ty_alphapair | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_alphapair
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } } 
 } 
 )
Show EXPLORED :: pp-path  ---> [?? : Base {v:Ty_alphapair | true}]

Show ***********Calling weakestPreSynththesis***************
Show ***********Calling bottomUpChoose***************
Show :: EXPLORED BW-CHOOSE :: WP :: PATH pp-path  ---> [?? : Base {v:Ty_alphapair | true}]

Show *********** Found a Hole***************[?? : Base {v:Ty_alphapair | true}]
 Show :: WP :: bindingVar var_ret7
Show &&&&&&&&&&&&& Potential Functions
 , 
 Showadd, 
 Showfresh_str, 
 Showcreate_pair
 Show :: CHOOSE NEXT WP  add
 Show *************** WP : Arrow Component ************add
 holeTYpe Base {v:Ty_alphapair | true}
 retTy MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < (ilssel)( , h, tbl ) = (Tbl)
 	 (mem)( , Tbl, s ) = (false) > } } 
 } 
 
                                                RET :  Base {v:Ty_unit | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_unit
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c (mem)( , Tbl', s ) = (true)
 	 , 
 	 Conj <c (size)(Tbl') ==((size)(Tbl) + (1))
 	 , (sel)( , h', num ) ==(sel)( , h, num ) >c  >c  >c  >c  } } 
 } 
 )
 Show *************** WP : Non-Match Return Type
Show WP HoleType : Base {v:Ty_alphapair | true}
Show WP ViRetTy  : Base {v:Ty_unit | true}
 Show :: CHOOSE NEXT WP  fresh_str
 Show *************** WP : Arrow Component ************fresh_str
 holeTYpe Base {v:Ty_alphapair | true}
 retTy MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Negation (sel)( , h, num ) > (2) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h', num ) ==((sel)( , h, num ) + (1))
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (ilssel)( , h, tbl )
 	 , (mem)( , Tbl', v ) = (false) >c  >c  >c  } } 
 } 
 )
 Show *************** WP : Non-Match Return Type
Show WP HoleType : Base {v:Ty_alphapair | true}
Show WP ViRetTy  : Base {v:Ty_int | true}
 Show :: CHOOSE NEXT WP  create_pair
 holeTYpe Base {v:Ty_alphapair | true}
 retTy Base {v:Ty_alphapair | true}
 Show *************** WP : Matching Return Type Ty_alphapair
 Show *************** WP : Synthesizing Args ei : ti for ************create_pair
Show :: esynthesizeScalar for Base {v:Ty_char | true}
Show :: No Scalar found, Call esynthesizePureApp 
Show :: In esynthesizePureApp 
Show Potential Functions
 
Show :: No pureApp found, Call esynthesizeConsApp 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
Show :: esynthesizeScalar for Base {v:Ty_float | true}
Show :: No Scalar found, Call esynthesizePureApp 
Show :: In esynthesizePureApp 
Show Potential Functions
 
Show :: No pureApp found, Call esynthesizeConsApp 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
 Show *************** WP : UPDATED PATH pp-path  ---> do locx8 <- [?? : Base {v:Ty_char | true}] ---> do locy9 <- [?? : Base {v:Ty_float | true}] ---> do var_ret7 <- apply create_pair  (, locx8 ), locy9 )

 Show :: WP :: NEW POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =var_v10 Value = Ty_unknown
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } }
Show ***********Incomplete Path :: Continue WP***************
Show ***********Calling bottomUpChoose***************
Show :: EXPLORED BW-CHOOSE :: WP :: PATH pp-path  ---> do locx8 <- [?? : Base {v:Ty_char | true}] ---> do locy9 <- [?? : Base {v:Ty_float | true}] ---> do var_ret7 <- apply create_pair  (, locx8 ), locy9 )

Show *********** Found a Hole***************do locy9 <- [?? : Base {v:Ty_float | true}]
 Show :: WP :: bindingVar locy9
Show &&&&&&&&&&&&& Potential Functions
 , 
 Showfresh_str, 
 Showadd
 Show :: CHOOSE NEXT WP  fresh_str
 Show *************** WP : Arrow Component ************fresh_str
 holeTYpe Base {v:Ty_float | true}
 retTy MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Negation (sel)( , h, num ) > (2) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h', num ) ==((sel)( , h, num ) + (1))
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h', tbl ) = (ilssel)( , h, tbl )
 	 , (mem)( , Tbl', v ) = (false) >c  >c  >c  } } 
 } 
 )
 Show *************** WP : Non-Match Return Type
Show WP HoleType : Base {v:Ty_float | true}
Show WP ViRetTy  : Base {v:Ty_int | true}
 Show :: CHOOSE NEXT WP  add
 Show *************** WP : Arrow Component ************add
 holeTYpe Base {v:Ty_float | true}
 retTy MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < (ilssel)( , h, tbl ) = (Tbl)
 	 (mem)( , Tbl, s ) = (false) > } } 
 } 
 
                                                RET :  Base {v:Ty_unit | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_unit
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (ilssel)( , h', tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c (mem)( , Tbl', s ) = (true)
 	 , 
 	 Conj <c (size)(Tbl') ==((size)(Tbl) + (1))
 	 , (sel)( , h', num ) ==(sel)( , h, num ) >c  >c  >c  >c  } } 
 } 
 )
 Show *************** WP : Non-Match Return Type
Show WP HoleType : Base {v:Ty_float | true}
Show WP ViRetTy  : Base {v:Ty_unit | true}
 Show : WP : Finished Backward Checks : Try forward 
Show ***********WP : FLIP/BREAK : Calling CDCL ***************
Show WP : BackwardPath pp-path  ---> do locx8 <- [?? : Base {v:Ty_char | true}] ---> do locy9 <- [?? : Base {v:Ty_float | true}] ---> do var_ret7 <- apply create_pair  (, locx8 ), locy9 )

Show :: Forward <k, h> = < 5, pp-path  ---> do locx8 <- [?? : Base {v:Ty_char | true}] ---> do locy9 <- [?? : Base {v:Ty_float | true}] ---> do var_ret7 <- apply create_pair  (, locx8 ), locy9 )

Show :: in CDCL :: GOAL MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , h, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  } } 
 } 
 
                                                RET :  Base {v:Ty_float | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =var_v10 Value = Ty_unknown
 Key =h' Value = Ty_heap{ Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Impl < 
 	 Conj <c (ilssel)( , h, tbl ) = (Tbl)
 	 , (ilssel)( , h', tbl ) = (Tbl') >c 
 	 (size)(Tbl') ==((size)(Tbl) + (2)) > } } 
 } 
 )
 EXPLORED :: pp-path 

CHOOSING FROM , add, fresh_str
Choice 
Show Component add
 Show *************** Arrow Component ************add
 Show *************** Synthesizing Args ei : ti for ************add
Show :: esynthesizeScalar for Base {v:Ty_int | true}SubTy Base {s:Ty_int | true}SuperTy Base {s:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))

Show :: Found a Few Macthing Scalars 
 Show *************** Successfully Synthesized Args ei Forall i 1
 
 Show Argij { 
Base {v:Ty_int | true} 
 s 
 }
 
 Show Headi { 
Base {v:Ty_int | true} 
 s 
 }
 Show **************  Syntactic Equivalent Stuckness Check********add
 potential Path pp-path  ---> do locbound11 <- apply add  (, s )

 visited Paths 

 
pp-path 

 Show *************** HSAT Successful ************add
 Show *************** Calling Hoare-Pre ************add
Potential Component/Function  apply add  (, s )
Show :: HoarePre Eapp case  apply add  (, s )
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_h12 --->  Ty_heap  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_var_h1213 --->  Ty_heap  
 var_Tbl14 --->  Ty_list Ty_int  
 var_Tbl15 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h1213, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h1213, tbl ) = (var_Tbl14) AND 
 	 Not Rel (0) > (size)(var_Tbl14) AND 
 	 Rel (mem)( , var_Tbl14, s ) = (true) => 
 	 Rel (ilssel)( , var_var_h1213, tbl ) = (var_Tbl15) => 
 	 Rel (mem)( , var_Tbl15, s ) = (false)
 
VC_END        
solver 
 (declare-sort T44)
(declare-sort T39)
(declare-sort T43)
(declare-sort T42)
(declare-fun set0 (Bool) Bool)
(declare-fun var_Tbl15 () T43)
(declare-fun set1 (T43) Bool)
(declare-fun var_Tbl14 () T43)
(declare-fun set2 (T43) Bool)
(declare-fun set3 (Bool) Bool)
(declare-fun mem (T43 Int Bool) Bool)
(declare-fun s () Int)
(declare-fun ilssel (T39 T44 T43) Bool)
(declare-fun tbl () T44)
(declare-fun var_var_h1213 () T39)
(declare-fun size (T43) Int)
(declare-fun sel (T39 T42) Int)
(declare-fun num () T42)
(assert true)
(assert (forall ((bv0 Bool)) (= (set0 bv0) (and (= bv0 false)))))
(assert (forall ((bv0 T43)) (= (set1 bv0) (and (= bv0 var_Tbl15)))))
(assert (forall ((bv0 T43)) (= (set2 bv0) (and (= bv0 var_Tbl14)))))
(assert (forall ((bv0 Bool)) (= (set3 bv0) (and (= bv0 true)))))
(assert (let ((a!1 (and (= (sel var_var_h1213 num) 0)
                (forall ((bv0 T43))
                  (= (ilssel var_var_h1213 tbl bv0) (set2 bv0)))
                (not (> 0 (size var_Tbl14)))
                (forall ((bv0 Bool)) (= (mem var_Tbl14 s bv0) (set3 bv0)))))
      (a!2 (=> (forall ((bv0 T43))
                 (= (ilssel var_var_h1213 tbl bv0) (set1 bv0)))
               (forall ((bv0 Bool)) (= (mem var_Tbl15 s bv0) (set0 bv0))))))
  (not (=> a!1 a!2))))

 Show *************** Hoare-Not-Allowed : Now Adding D(ci) Disjuncts ************
Choice 
Show Component fresh_str
 Show **************  Syntactic Equivalent Stuckness Check********fresh_str
 potential Path pp-path  ---> do locbound16 <- apply fresh_str  (

 visited Paths 

 
pp-path 

 Show *************** HSAT Successful ************fresh_str
 Show *************** Calling Hoare-Pre ************fresh_str
Potential Component/Function  fresh_str
Show :: HoarePre Evar case  fresh_str
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_h17 --->  Ty_heap  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_var_h1718 --->  Ty_heap  
 var_Tbl19 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h1718, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h1718, tbl ) = (var_Tbl19) AND 
 	 Not Rel (0) > (size)(var_Tbl19) AND 
 	 Rel (mem)( , var_Tbl19, s ) = (true) => 
 	 Not Rel (sel)( , var_var_h1718, num ) > (2)
 
VC_END    
solver 
 (declare-sort T83)
(declare-sort T78)
(declare-sort T82)
(declare-sort T81)
(declare-fun var_Tbl19 () T82)
(declare-fun set4 (T82) Bool)
(declare-fun set5 (Bool) Bool)
(declare-fun sel (T78 T81) Int)
(declare-fun num () T81)
(declare-fun var_var_h1718 () T78)
(declare-fun mem (T82 Int Bool) Bool)
(declare-fun s () Int)
(declare-fun size (T82) Int)
(declare-fun ilssel (T78 T83 T82) Bool)
(declare-fun tbl () T83)
(assert true)
(assert (forall ((bv0 T82)) (= (set4 bv0) (and (= bv0 var_Tbl19)))))
(assert (forall ((bv0 Bool)) (= (set5 bv0) (and (= bv0 true)))))
(assert (let ((a!1 (and (= (sel var_var_h1718 num) 0)
                (forall ((bv0 T82))
                  (= (ilssel var_var_h1718 tbl bv0) (set4 bv0)))
                (not (> 0 (size var_Tbl19)))
                (forall ((bv0 Bool)) (= (mem var_Tbl19 s bv0) (set5 bv0))))))
(let ((a!2 (=> a!1 (not (> (sel var_var_h1718 num) 2)))))
  (not a!2))))

 Show *************** 
                                                    Hoare-Allowed : Now Checking distingushing Predicate ************fresh_str
 Show ***************Distinguish Call************fresh_str
Show ***********DiffPredicate true
 Show ***************Checking ~ (D(ci).previous => sp (pre, (path :: ci))************fresh_str
 Show ************ D(ci).previous == True true
 Show *************** Distinguished : Returning the choice ************fresh_str
 EXPLORED :: pp-path  ---> do locbound16 <- apply fresh_str  (

Show :: Chosen do locbound16 <- apply fresh_str  (
 Show :: Run deduceR
 EXPLORED :: pp-path  ---> do locbound16 <- apply fresh_str  (

 Found a type for the path in the PMap
Show :: Return Type Mismatch pp-path  ---> do locbound16 <- apply fresh_str  (
 Now checking for a scalar or a pure component to reach goal type 
Show :: esynthesizeScalar for Base {v:Ty_float | true}
Show :: No Scalar found, Call esynthesizePureApp 
Show :: In esynthesizePureApp 
Show Potential Functions
 
Show :: No pureApp found, Call esynthesizeConsApp 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
Show :: In esynthesizePureApp 
Show Potential Functions
 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
Show :: Checking (SP (P, pi) => Post Failed) pp-path  ---> do locbound16 <- apply fresh_str  (

Show :: Incomplete Path pp-path  ---> do locbound16 <- apply fresh_str  (
 Now chosing Next component 
CHOOSING FROM , fresh_str, add
Choice 
Show Component fresh_str
 Show **************  Syntactic Equivalent Stuckness Check********fresh_str
 potential Path pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

 visited Paths 

 
pp-path 

 Show *************** HSAT Successful ************fresh_str
 Show *************** Calling Hoare-Pre ************fresh_str
Potential Component/Function  fresh_str
Show :: HoarePre Evar case  fresh_str
 Found a type for the path in the PMap
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_x32 --->  Ty_int  
 var_h'31 --->  Ty_heap  
 var_h30 --->  Ty_heap  
 locbound16 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_var_h3033 --->  Ty_heap  
 var_var_x3234 --->  Ty_int  
 var_var_h'3135 --->  Ty_heap  
 var_Tbl36 --->  Ty_list Ty_int  
 var_Tbl37 --->  Ty_list Ty_int  
 var_Tbl'38 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h3033, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h3033, tbl ) = (var_Tbl36) AND 
 	 Not Rel (0) > (size)(var_Tbl36) AND 
 	 Rel (mem)( , var_Tbl36, s ) = (true) AND 
 	 Rel (sel)( , var_var_h3033, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h3033, tbl ) = (var_Tbl37) AND 
 	 Not Rel (0) > (size)(var_Tbl37) AND 
 	 Rel (mem)( , var_Tbl37, s ) = (true) AND 
 	 Base var_var_h3033 = var_h_int24 AND 
 	 Rel (sel)( , var_var_h'3135, num ) ==((sel)( , var_h_int24, num ) + (1)) AND 
 	 Rel (ilssel)( , var_var_h'3135, tbl ) = (var_Tbl'38) AND 
 	 Rel (ilssel)( , var_var_h'3135, tbl ) = (ilssel)( , var_h_int24, tbl ) AND 
 	 Rel (mem)( , var_Tbl'38, var_var_x3234 ) = (false) AND 
 	 Base locbound16 = var_var_x3234 => 
 	 Not Rel (sel)( , var_var_h'3135, num ) > (2)
 
VC_END                          
solver 
 (declare-sort T122)
(declare-sort T120)
(declare-sort T121)
(declare-sort T117)
(declare-fun var_Tbl36 () T121)
(declare-fun set6 (T121) Bool)
(declare-fun set7 (Bool) Bool)
(declare-fun var_Tbl37 () T121)
(declare-fun set8 (T121) Bool)
(declare-fun set9 (Bool) Bool)
(declare-fun |var_Tbl'38| () T121)
(declare-fun set10 (T121) Bool)
(declare-fun set11 (Bool) Bool)
(declare-fun sel (T117 T120) Int)
(declare-fun num () T120)
(declare-fun |var_var_h'3135| () T117)
(declare-fun var_var_x3234 () Int)
(declare-fun locbound16 () Int)
(declare-fun mem (T121 Int Bool) Bool)
(declare-fun ilssel (T117 T122 T121) Bool)
(declare-fun tbl () T122)
(declare-fun var_h_int24 () T117)
(declare-fun var_var_h3033 () T117)
(declare-fun s () Int)
(declare-fun size (T121) Int)
(assert true)
(assert (forall ((bv0 T121)) (= (set6 bv0) (and (= bv0 var_Tbl36)))))
(assert (forall ((bv0 Bool)) (= (set7 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T121)) (= (set8 bv0) (and (= bv0 var_Tbl37)))))
(assert (forall ((bv0 Bool)) (= (set9 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T121)) (= (set10 bv0) (and (= bv0 |var_Tbl'38|)))))
(assert (forall ((bv0 Bool)) (= (set11 bv0) (and (= bv0 false)))))
(assert (let ((a!1 (and (= (sel var_var_h3033 num) 0)
                (forall ((bv0 T121))
                  (= (ilssel var_var_h3033 tbl bv0) (set6 bv0)))
                (not (> 0 (size var_Tbl36)))
                (forall ((bv0 Bool)) (= (mem var_Tbl36 s bv0) (set7 bv0)))
                (= (sel var_var_h3033 num) 0)
                (forall ((bv0 T121))
                  (= (ilssel var_var_h3033 tbl bv0) (set8 bv0)))
                (not (> 0 (size var_Tbl37)))
                (forall ((bv0 Bool)) (= (mem var_Tbl37 s bv0) (set9 bv0)))
                (= var_var_h3033 var_h_int24)
                (= (sel |var_var_h'3135| num) (+ (sel var_h_int24 num) 1))
                (forall ((bv0 T121))
                  (= (ilssel |var_var_h'3135| tbl bv0) (set10 bv0)))
                (forall ((bv0 T121))
                  (= (ilssel |var_var_h'3135| tbl bv0)
                     (ilssel var_h_int24 tbl bv0)))
                (forall ((bv0 Bool))
                  (= (mem |var_Tbl'38| var_var_x3234 bv0) (set11 bv0)))
                (= locbound16 var_var_x3234))))
(let ((a!2 (=> a!1 (not (> (sel |var_var_h'3135| num) 2)))))
  (not a!2))))

 Show *************** 
                                                    Hoare-Allowed : Now Checking distingushing Predicate ************fresh_str
 Show ***************Distinguish Call************fresh_str
Show ***********DiffPredicate true
 Show ***************Checking ~ (D(ci).previous => sp (pre, (path :: ci))************fresh_str
 Show ************ D(ci).previous == True Forall 
 	 
 Key =var_h25 Value = Ty_heap
 Key =var_v28 Value = Ty_int
 Key =var_h'27 Value = Ty_heap{ 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c Forall 
 	 
 Key =Tbl Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , var_h25, num ) ==(0)
 	 , 
 	 Conj <c (ilssel)( , var_h25, tbl ) = (Tbl)
 	 , 
 	 Conj <c Negation (0) > (size)(Tbl)
 	 , (mem)( , Tbl, s ) = (true) >c  >c  >c  }
 	 , var_h25 = var_h_int24 >c 
 	 , Forall 
 	 
 Key =Tbl' Value = Ty_list Ty_int{ 
 	 Conj <c (sel)( , var_h'27, num ) ==((sel)( , var_h_int24, num ) + (1))
 	 , 
 	 Conj <c (ilssel)( , var_h'27, tbl ) = (Tbl')
 	 , 
 	 Conj <c (ilssel)( , var_h'27, tbl ) = (ilssel)( , var_h_int24, tbl )
 	 , (mem)( , Tbl', var_v28 ) = (false) >c  >c  >c  } >c 
 	 , locbound16 = var_v28 >c  }
 Show *************** Distinguished : Returning the choice ************fresh_str
Show :: Chosen  do locbound29 <- apply fresh_str  (
 EXPLORED :: pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

 Found a type for the path in the PMap
Show :: Return Type Mismatch pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (
 Now checking for a scalar or a pure component to reach goal type 
Show :: esynthesizeScalar for Base {v:Ty_float | true}
Show :: No Scalar found, Call esynthesizePureApp 
Show :: In esynthesizePureApp 
Show Potential Functions
 
Show :: No pureApp found, Call esynthesizeConsApp 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
Show :: In esynthesizePureApp 
Show Potential Functions
 
Found Cons
Show esynthesizeConsApp 
Found Cons
 
Show No more choices for ConsApp
Show :: Checking (SP (P, pi) => Post Failed) pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

Show :: Incomplete Path pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (
 Now chosing Next component 
CHOOSING FROM , add, fresh_str
Choice 
Show Component add
 Show *************** Arrow Component ************add
 Show *************** Synthesizing Args ei : ti for ************add
Show :: esynthesizeScalar for Base {v:Ty_int | true}

 Show ::  Initial locbSubTy Base {locbound29:Ty_int | true}SuperTy Base {locbound29:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 locbound29 --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))
SubTy Base {s:Ty_int | true}SuperTy Base {s:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))


 Show ::  Initial locbSubTy Base {locbound16:Ty_int | true}SuperTy Base {locbound16:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 locbound16 --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))


 Show ::  Initial var_
Show :: Found a Few Macthing Scalars 
 Show *************** Successfully Synthesized Args ei Forall i 1
 
 Show Argij { 
Base {v:Ty_int | true} 
 locbound16 
 }
 
 Show Argij { 
Base {v:Ty_int | true} 
 s 
 }
 
 Show Argij { 
Base {v:Ty_int | true} 
 locbound29 
 }
 
 Show Headi { 
Base {v:Ty_int | true} 
 s 
 }
 Show **************  Syntactic Equivalent Stuckness Check********add
 potential Path pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  ( ---> do locbound53 <- apply add  (, s )

 visited Paths 

 
pp-path 

 Show *************** HSAT Successful ************add
 Show *************** Calling Hoare-Pre ************add
Potential Component/Function  apply add  (, s )
Show :: HoarePre Eapp case  apply add  (, s )
 Found a type for the path in the PMap
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_x56 --->  Ty_int  
 var_h'55 --->  Ty_heap  
 var_h54 --->  Ty_heap  
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 var_var_h5457 --->  Ty_heap  
 var_var_x5658 --->  Ty_int  
 var_var_h'5559 --->  Ty_heap  
 var_Tbl60 --->  Ty_list Ty_int  
 var_Tbl61 --->  Ty_list Ty_int  
 var_Tbl'62 --->  Ty_list Ty_int  
 var_Tbl'63 --->  Ty_list Ty_int  
 var_Tbl64 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h5457, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h5457, tbl ) = (var_Tbl60) AND 
 	 Not Rel (0) > (size)(var_Tbl60) AND 
 	 Rel (mem)( , var_Tbl60, s ) = (true) AND 
 	 Rel (sel)( , var_var_h5457, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h5457, tbl ) = (var_Tbl61) AND 
 	 Not Rel (0) > (size)(var_Tbl61) AND 
 	 Rel (mem)( , var_Tbl61, s ) = (true) AND 
 	 Base var_var_h5457 = var_h_int43 AND 
 	 Rel (sel)( , var_h_int48, num ) ==((sel)( , var_h_int43, num ) + (1)) AND 
 	 Rel (ilssel)( , var_h_int48, tbl ) = (var_Tbl'62) AND 
 	 Rel (ilssel)( , var_h_int48, tbl ) = (ilssel)( , var_h_int43, tbl ) AND 
 	 Rel (mem)( , var_Tbl'62, var_x50 ) = (false) AND 
 	 Base locbound16 = var_x50 AND 
 	 Rel (sel)( , var_var_h'5559, num ) ==((sel)( , var_h_int48, num ) + (1)) AND 
 	 Rel (ilssel)( , var_var_h'5559, tbl ) = (var_Tbl'63) AND 
 	 Rel (ilssel)( , var_var_h'5559, tbl ) = (ilssel)( , var_h_int48, tbl ) AND 
 	 Rel (mem)( , var_Tbl'63, var_var_x5658 ) = (false) AND 
 	 Base locbound29 = var_var_x5658 => 
 	 Rel (ilssel)( , var_var_h'5559, tbl ) = (var_Tbl64) => 
 	 Rel (mem)( , var_Tbl64, s ) = (false)
 
VC_END                                          
solver 
 (declare-sort T280)
(declare-sort T281)
(declare-sort T282)
(declare-sort T277)
(declare-fun set12 (Bool) Bool)
(declare-fun var_Tbl64 () T281)
(declare-fun set13 (T281) Bool)
(declare-fun var_Tbl60 () T281)
(declare-fun set14 (T281) Bool)
(declare-fun set15 (Bool) Bool)
(declare-fun var_Tbl61 () T281)
(declare-fun set16 (T281) Bool)
(declare-fun set17 (Bool) Bool)
(declare-fun |var_Tbl'62| () T281)
(declare-fun set18 (T281) Bool)
(declare-fun set19 (Bool) Bool)
(declare-fun |var_Tbl'63| () T281)
(declare-fun set20 (T281) Bool)
(declare-fun set21 (Bool) Bool)
(declare-fun mem (T281 Int Bool) Bool)
(declare-fun s () Int)
(declare-fun ilssel (T277 T282 T281) Bool)
(declare-fun tbl () T282)
(declare-fun |var_var_h'5559| () T277)
(declare-fun var_var_x5658 () Int)
(declare-fun locbound29 () Int)
(declare-fun var_h_int48 () T277)
(declare-fun sel (T277 T280) Int)
(declare-fun num () T280)
(declare-fun var_x50 () Int)
(declare-fun locbound16 () Int)
(declare-fun var_h_int43 () T277)
(declare-fun var_var_h5457 () T277)
(declare-fun size (T281) Int)
(assert true)
(assert (forall ((bv0 Bool)) (= (set12 bv0) (and (= bv0 false)))))
(assert (forall ((bv0 T281)) (= (set13 bv0) (and (= bv0 var_Tbl64)))))
(assert (forall ((bv0 T281)) (= (set14 bv0) (and (= bv0 var_Tbl60)))))
(assert (forall ((bv0 Bool)) (= (set15 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T281)) (= (set16 bv0) (and (= bv0 var_Tbl61)))))
(assert (forall ((bv0 Bool)) (= (set17 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T281)) (= (set18 bv0) (and (= bv0 |var_Tbl'62|)))))
(assert (forall ((bv0 Bool)) (= (set19 bv0) (and (= bv0 false)))))
(assert (forall ((bv0 T281)) (= (set20 bv0) (and (= bv0 |var_Tbl'63|)))))
(assert (forall ((bv0 Bool)) (= (set21 bv0) (and (= bv0 false)))))
(assert (let ((a!1 (and (= (sel var_var_h5457 num) 0)
                (forall ((bv0 T281))
                  (= (ilssel var_var_h5457 tbl bv0) (set14 bv0)))
                (not (> 0 (size var_Tbl60)))
                (forall ((bv0 Bool)) (= (mem var_Tbl60 s bv0) (set15 bv0)))
                (= (sel var_var_h5457 num) 0)
                (forall ((bv0 T281))
                  (= (ilssel var_var_h5457 tbl bv0) (set16 bv0)))
                (not (> 0 (size var_Tbl61)))
                (forall ((bv0 Bool)) (= (mem var_Tbl61 s bv0) (set17 bv0)))
                (= var_var_h5457 var_h_int43)
                (= (sel var_h_int48 num) (+ (sel var_h_int43 num) 1))
                (forall ((bv0 T281))
                  (= (ilssel var_h_int48 tbl bv0) (set18 bv0)))
                (forall ((bv0 T281))
                  (= (ilssel var_h_int48 tbl bv0) (ilssel var_h_int43 tbl bv0)))
                (forall ((bv0 Bool))
                  (= (mem |var_Tbl'62| var_x50 bv0) (set19 bv0)))
                (= locbound16 var_x50)
                (= (sel |var_var_h'5559| num) (+ (sel var_h_int48 num) 1))
                (forall ((bv0 T281))
                  (= (ilssel |var_var_h'5559| tbl bv0) (set20 bv0)))
                (forall ((bv0 T281))
                  (= (ilssel |var_var_h'5559| tbl bv0)
                     (ilssel var_h_int48 tbl bv0)))
                (forall ((bv0 Bool))
                  (= (mem |var_Tbl'63| var_var_x5658 bv0) (set21 bv0)))
                (= locbound29 var_var_x5658)))
      (a!2 (=> (forall ((bv0 T281))
                 (= (ilssel |var_var_h'5559| tbl bv0) (set13 bv0)))
               (forall ((bv0 Bool)) (= (mem var_Tbl64 s bv0) (set12 bv0))))))
  (not (=> a!1 a!2))))

 Show *************** Hoare-Not-Allowed : Now Adding D(ci) Disjuncts ************
Choice 
Show Component fresh_str
 Show **************  Syntactic Equivalent Stuckness Check********fresh_str
 potential Path pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  ( ---> do locbound65 <- apply fresh_str  (

 visited Paths 

 
pp-path 

 Show *************** HSAT Successful ************fresh_str
 Show *************** Calling Hoare-Pre ************fresh_str
Potential Component/Function  fresh_str
Show :: HoarePre Evar case  fresh_str
 Found a type for the path in the PMap
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_x68 --->  Ty_int  
 var_h'67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 var_var_h6669 --->  Ty_heap  
 var_var_x6870 --->  Ty_int  
 var_var_h'6771 --->  Ty_heap  
 var_Tbl72 --->  Ty_list Ty_int  
 var_Tbl73 --->  Ty_list Ty_int  
 var_Tbl'74 --->  Ty_list Ty_int  
 var_Tbl'75 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h6669, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h6669, tbl ) = (var_Tbl72) AND 
 	 Not Rel (0) > (size)(var_Tbl72) AND 
 	 Rel (mem)( , var_Tbl72, s ) = (true) AND 
 	 Rel (sel)( , var_var_h6669, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h6669, tbl ) = (var_Tbl73) AND 
 	 Not Rel (0) > (size)(var_Tbl73) AND 
 	 Rel (mem)( , var_Tbl73, s ) = (true) AND 
 	 Base var_var_h6669 = var_h_int43 AND 
 	 Rel (sel)( , var_h_int48, num ) ==((sel)( , var_h_int43, num ) + (1)) AND 
 	 Rel (ilssel)( , var_h_int48, tbl ) = (var_Tbl'74) AND 
 	 Rel (ilssel)( , var_h_int48, tbl ) = (ilssel)( , var_h_int43, tbl ) AND 
 	 Rel (mem)( , var_Tbl'74, var_x50 ) = (false) AND 
 	 Base locbound16 = var_x50 AND 
 	 Rel (sel)( , var_var_h'6771, num ) ==((sel)( , var_h_int48, num ) + (1)) AND 
 	 Rel (ilssel)( , var_var_h'6771, tbl ) = (var_Tbl'75) AND 
 	 Rel (ilssel)( , var_var_h'6771, tbl ) = (ilssel)( , var_h_int48, tbl ) AND 
 	 Rel (mem)( , var_Tbl'75, var_var_x6870 ) = (false) AND 
 	 Base locbound29 = var_var_x6870 => 
 	 Not Rel (sel)( , var_var_h'6771, num ) > (2)
 
VC_END                                      
solver 
 (declare-sort T320)
(declare-sort T321)
(declare-sort T317)
(declare-sort T322)
(declare-fun var_Tbl72 () T321)
(declare-fun set22 (T321) Bool)
(declare-fun set23 (Bool) Bool)
(declare-fun var_Tbl73 () T321)
(declare-fun set24 (T321) Bool)
(declare-fun set25 (Bool) Bool)
(declare-fun |var_Tbl'74| () T321)
(declare-fun set26 (T321) Bool)
(declare-fun set27 (Bool) Bool)
(declare-fun |var_Tbl'75| () T321)
(declare-fun set28 (T321) Bool)
(declare-fun set29 (Bool) Bool)
(declare-fun sel (T317 T320) Int)
(declare-fun num () T320)
(declare-fun |var_var_h'6771| () T317)
(declare-fun var_var_x6870 () Int)
(declare-fun locbound29 () Int)
(declare-fun mem (T321 Int Bool) Bool)
(declare-fun ilssel (T317 T322 T321) Bool)
(declare-fun tbl () T322)
(declare-fun var_h_int48 () T317)
(declare-fun var_x50 () Int)
(declare-fun locbound16 () Int)
(declare-fun var_h_int43 () T317)
(declare-fun var_var_h6669 () T317)
(declare-fun s () Int)
(declare-fun size (T321) Int)
(assert true)
(assert (forall ((bv0 T321)) (= (set22 bv0) (and (= bv0 var_Tbl72)))))
(assert (forall ((bv0 Bool)) (= (set23 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T321)) (= (set24 bv0) (and (= bv0 var_Tbl73)))))
(assert (forall ((bv0 Bool)) (= (set25 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T321)) (= (set26 bv0) (and (= bv0 |var_Tbl'74|)))))
(assert (forall ((bv0 Bool)) (= (set27 bv0) (and (= bv0 false)))))
(assert (forall ((bv0 T321)) (= (set28 bv0) (and (= bv0 |var_Tbl'75|)))))
(assert (forall ((bv0 Bool)) (= (set29 bv0) (and (= bv0 false)))))
(assert (let ((a!1 (and (= (sel var_var_h6669 num) 0)
                (forall ((bv0 T321))
                  (= (ilssel var_var_h6669 tbl bv0) (set22 bv0)))
                (not (> 0 (size var_Tbl72)))
                (forall ((bv0 Bool)) (= (mem var_Tbl72 s bv0) (set23 bv0)))
                (= (sel var_var_h6669 num) 0)
                (forall ((bv0 T321))
                  (= (ilssel var_var_h6669 tbl bv0) (set24 bv0)))
                (not (> 0 (size var_Tbl73)))
                (forall ((bv0 Bool)) (= (mem var_Tbl73 s bv0) (set25 bv0)))
                (= var_var_h6669 var_h_int43)
                (= (sel var_h_int48 num) (+ (sel var_h_int43 num) 1))
                (forall ((bv0 T321))
                  (= (ilssel var_h_int48 tbl bv0) (set26 bv0)))
                (forall ((bv0 T321))
                  (= (ilssel var_h_int48 tbl bv0) (ilssel var_h_int43 tbl bv0)))
                (forall ((bv0 Bool))
                  (= (mem |var_Tbl'74| var_x50 bv0) (set27 bv0)))
                (= locbound16 var_x50)
                (= (sel |var_var_h'6771| num) (+ (sel var_h_int48 num) 1))
                (forall ((bv0 T321))
                  (= (ilssel |var_var_h'6771| tbl bv0) (set28 bv0)))
                (forall ((bv0 T321))
                  (= (ilssel |var_var_h'6771| tbl bv0)
                     (ilssel var_h_int48 tbl bv0)))
                (forall ((bv0 Bool))
                  (= (mem |var_Tbl'75| var_var_x6870 bv0) (set29 bv0)))
                (= locbound29 var_var_x6870))))
(let ((a!2 (=> a!1 (not (> (sel |var_var_h'6771| num) 2)))))
  (not a!2))))

 Show *************** 
                                                    Hoare-Allowed : Now Checking distingushing Predicate ************fresh_str
 Show ***************Distinguish Call************fresh_str
Show ***********DiffPredicate true
 Show ***************Checking ~ (D(ci).previous => sp (pre, (path :: ci))************fresh_str
 Show *************** Not-Distinguished : 
                                                                Now Adding conjunct ************fresh_str
Choice 
Show :: Conflicting path found pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

 Show :: Conflict Path  Found  :: Calling learnP Now
**************Show :: Backtracking From ********pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

**************Show :: Backtracked to ********pp-path  ---> do locbound16 <- apply fresh_str  (

**************Show :: LOOP ********pp-path  ---> do locbound16 <- apply fresh_str  (

 EXPLORED :: pp-path  ---> do locbound16 <- apply fresh_str  (

CHOOSING FROM , fresh_str, add
Choice 
Show Component fresh_str
 Show **************  Syntactic Equivalent Stuckness Check********fresh_str
 potential Path pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound95 <- apply fresh_str  (

 visited Paths 

 
pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

pp-path 

Choice 
Show Component add
 Show *************** Arrow Component ************add
 Show *************** Synthesizing Args ei : ti for ************add
Show :: esynthesizeScalar for Base {v:Ty_int | true}

 Show ::  Initial locbSubTy Base {locbound29:Ty_int | true}SuperTy Base {locbound29:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 locbound29 --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))
SubTy Base {s:Ty_int | true}SuperTy Base {s:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))


 Show ::  Initial locbSubTy Base {locbound16:Ty_int | true}SuperTy Base {locbound16:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 locbound16 --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))


 Show ::  Initial var_
Show :: Found a Few Macthing Scalars 
 Show *************** Successfully Synthesized Args ei Forall i 1
 
 Show Argij { 
Base {v:Ty_int | true} 
 locbound16 
 }
 
 Show Argij { 
Base {v:Ty_int | true} 
 s 
 }
 
 Show Argij { 
Base {v:Ty_int | true} 
 locbound29 
 }
 
 Show Headi { 
Base {v:Ty_int | true} 
 s 
 }
 Show **************  Syntactic Equivalent Stuckness Check********add
 potential Path pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound96 <- apply add  (, s )

 visited Paths 

 
pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

pp-path 

 Show *************** HSAT Successful ************add
 Show *************** Calling Hoare-Pre ************add
Potential Component/Function  apply add  (, s )
Show :: HoarePre Eapp case  apply add  (, s )
 Found a type for the path in the PMap
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_x99 --->  Ty_int  
 var_h'98 --->  Ty_heap  
 var_h97 --->  Ty_heap  
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 var_var_h97100 --->  Ty_heap  
 var_var_x99101 --->  Ty_int  
 var_var_h'98102 --->  Ty_heap  
 var_Tbl103 --->  Ty_list Ty_int  
 var_Tbl104 --->  Ty_list Ty_int  
 var_Tbl'105 --->  Ty_list Ty_int  
 var_Tbl106 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h97100, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h97100, tbl ) = (var_Tbl103) AND 
 	 Not Rel (0) > (size)(var_Tbl103) AND 
 	 Rel (mem)( , var_Tbl103, s ) = (true) AND 
 	 Rel (sel)( , var_var_h97100, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h97100, tbl ) = (var_Tbl104) AND 
 	 Not Rel (0) > (size)(var_Tbl104) AND 
 	 Rel (mem)( , var_Tbl104, s ) = (true) AND 
 	 Base var_var_h97100 = var_h_int24 AND 
 	 Rel (sel)( , var_var_h'98102, num ) ==((sel)( , var_h_int24, num ) + (1)) AND 
 	 Rel (ilssel)( , var_var_h'98102, tbl ) = (var_Tbl'105) AND 
 	 Rel (ilssel)( , var_var_h'98102, tbl ) = (ilssel)( , var_h_int24, tbl ) AND 
 	 Rel (mem)( , var_Tbl'105, var_var_x99101 ) = (false) AND 
 	 Base locbound16 = var_var_x99101 => 
 	 Rel (ilssel)( , var_var_h'98102, tbl ) = (var_Tbl106) => 
 	 Rel (mem)( , var_Tbl106, s ) = (false)
 
VC_END                              
solver 
 (declare-sort T477)
(declare-sort T481)
(declare-sort T482)
(declare-sort T480)
(declare-fun set30 (Bool) Bool)
(declare-fun var_Tbl106 () T481)
(declare-fun set31 (T481) Bool)
(declare-fun var_Tbl103 () T481)
(declare-fun set32 (T481) Bool)
(declare-fun set33 (Bool) Bool)
(declare-fun var_Tbl104 () T481)
(declare-fun set34 (T481) Bool)
(declare-fun set35 (Bool) Bool)
(declare-fun |var_Tbl'105| () T481)
(declare-fun set36 (T481) Bool)
(declare-fun set37 (Bool) Bool)
(declare-fun mem (T481 Int Bool) Bool)
(declare-fun s () Int)
(declare-fun ilssel (T477 T482 T481) Bool)
(declare-fun tbl () T482)
(declare-fun |var_var_h'98102| () T477)
(declare-fun var_var_x99101 () Int)
(declare-fun locbound16 () Int)
(declare-fun var_h_int24 () T477)
(declare-fun sel (T477 T480) Int)
(declare-fun num () T480)
(declare-fun var_var_h97100 () T477)
(declare-fun size (T481) Int)
(assert true)
(assert (forall ((bv0 Bool)) (= (set30 bv0) (and (= bv0 false)))))
(assert (forall ((bv0 T481)) (= (set31 bv0) (and (= bv0 var_Tbl106)))))
(assert (forall ((bv0 T481)) (= (set32 bv0) (and (= bv0 var_Tbl103)))))
(assert (forall ((bv0 Bool)) (= (set33 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T481)) (= (set34 bv0) (and (= bv0 var_Tbl104)))))
(assert (forall ((bv0 Bool)) (= (set35 bv0) (and (= bv0 true)))))
(assert (forall ((bv0 T481)) (= (set36 bv0) (and (= bv0 |var_Tbl'105|)))))
(assert (forall ((bv0 Bool)) (= (set37 bv0) (and (= bv0 false)))))
(assert (let ((a!1 (and (= (sel var_var_h97100 num) 0)
                (forall ((bv0 T481))
                  (= (ilssel var_var_h97100 tbl bv0) (set32 bv0)))
                (not (> 0 (size var_Tbl103)))
                (forall ((bv0 Bool)) (= (mem var_Tbl103 s bv0) (set33 bv0)))
                (= (sel var_var_h97100 num) 0)
                (forall ((bv0 T481))
                  (= (ilssel var_var_h97100 tbl bv0) (set34 bv0)))
                (not (> 0 (size var_Tbl104)))
                (forall ((bv0 Bool)) (= (mem var_Tbl104 s bv0) (set35 bv0)))
                (= var_var_h97100 var_h_int24)
                (= (sel |var_var_h'98102| num) (+ (sel var_h_int24 num) 1))
                (forall ((bv0 T481))
                  (= (ilssel |var_var_h'98102| tbl bv0) (set36 bv0)))
                (forall ((bv0 T481))
                  (= (ilssel |var_var_h'98102| tbl bv0)
                     (ilssel var_h_int24 tbl bv0)))
                (forall ((bv0 Bool))
                  (= (mem |var_Tbl'105| var_var_x99101 bv0) (set37 bv0)))
                (= locbound16 var_var_x99101)))
      (a!2 (=> (forall ((bv0 T481))
                 (= (ilssel |var_var_h'98102| tbl bv0) (set31 bv0)))
               (forall ((bv0 Bool)) (= (mem var_Tbl106 s bv0) (set30 bv0))))))
  (not (=> a!1 a!2))))

 Show *************** Hoare-Not-Allowed : Now Adding D(ci) Disjuncts ************
Choice 
 Show :: Conflict Path  Found  while backtracking
 Found a type for the path in the PMap
**************Show :: Backtracking From ********pp-path  ---> do locbound16 <- apply fresh_str  (

**************Show :: Backtracked To ********pp-path 

 EXPLORED :: pp-path 

CHOOSING FROM , add, fresh_str
Choice 
Show Component add
 Show *************** Arrow Component ************add
 Show *************** Synthesizing Args ei : ti for ************add
Show :: esynthesizeScalar for Base {v:Ty_int | true}

 Show ::  Initial locbSubTy Base {locbound29:Ty_int | true}SuperTy Base {locbound29:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 locbound29 --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))
SubTy Base {s:Ty_int | true}SuperTy Base {s:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))


 Show ::  Initial locbSubTy Base {locbound16:Ty_int | true}SuperTy Base {locbound16:Ty_int | true}
 Standardizing verification conditions 
standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 locbound16 --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
solver 
 (assert true)
(assert (not true))


 Show ::  Initial var_
Show :: Found a Few Macthing Scalars 
 Show *************** Successfully Synthesized Args ei Forall i 1
 
 Show Argij { 
Base {v:Ty_int | true} 
 locbound16 
 }
 
 Show Argij { 
Base {v:Ty_int | true} 
 s 
 }
 
 Show Argij { 
Base {v:Ty_int | true} 
 locbound29 
 }
 
 Show Headi { 
Base {v:Ty_int | true} 
 s 
 }
 Show **************  Syntactic Equivalent Stuckness Check********add
 potential Path pp-path  ---> do locbound107 <- apply add  (, s )

 visited Paths 

 
pp-path  ---> do locbound16 <- apply fresh_str  (

pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

pp-path 

 Show *************** HSAT Successful ************add
 Show *************** Calling Hoare-Pre ************add
Potential Component/Function  apply add  (, s )
Show :: HoarePre Eapp case  apply add  (, s )
 Standardizing verification conditions 

 Printing VCs

STANDARD VC_BEGIN TyDBINDS  
 
 var_h108 --->  Ty_heap  
 locbound29 --->  Ty_int  
 add --->  Function type  
 fresh_str --->  Ty_int  
 create_pair --->  Function type  
 num --->  Ty_ref Ty_int  
 Tbl --->  Ty_list Ty_int  
 Tbl' --->  Ty_list Ty_int  
 tbl --->  Ty_ref Ty_list Ty_int  
 s --->  Ty_int  
 var_h_int24 --->  Ty_heap  
 var_x26 --->  Ty_unknown  
 var_h_int43 --->  Ty_heap  
 var_x45 --->  Ty_unknown  
 locbound16 --->  Ty_int  
 var_h_int48 --->  Ty_heap  
 var_x50 --->  Ty_int  
 var_var_h108109 --->  Ty_heap  
 var_Tbl110 --->  Ty_list Ty_int  
 var_Tbl111 --->  Ty_list Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var_var_h108109, num ) ==(0) AND 
 	 Rel (ilssel)( , var_var_h108109, tbl ) = (var_Tbl110) AND 
 	 Not Rel (0) > (size)(var_Tbl110) AND 
 	 Rel (mem)( , var_Tbl110, s ) = (true) => 
 	 Rel (ilssel)( , var_var_h108109, tbl ) = (var_Tbl111) => 
 	 Rel (mem)( , var_Tbl111, s ) = (false)
 
VC_END        
solver 
 (declare-sort T642)
(declare-sort T641)
(declare-sort T637)
(declare-sort T640)
(declare-fun set38 (Bool) Bool)
(declare-fun var_Tbl111 () T641)
(declare-fun set39 (T641) Bool)
(declare-fun var_Tbl110 () T641)
(declare-fun set40 (T641) Bool)
(declare-fun set41 (Bool) Bool)
(declare-fun mem (T641 Int Bool) Bool)
(declare-fun s () Int)
(declare-fun ilssel (T637 T642 T641) Bool)
(declare-fun tbl () T642)
(declare-fun var_var_h108109 () T637)
(declare-fun size (T641) Int)
(declare-fun sel (T637 T640) Int)
(declare-fun num () T640)
(assert true)
(assert (forall ((bv0 Bool)) (= (set38 bv0) (and (= bv0 false)))))
(assert (forall ((bv0 T641)) (= (set39 bv0) (and (= bv0 var_Tbl111)))))
(assert (forall ((bv0 T641)) (= (set40 bv0) (and (= bv0 var_Tbl110)))))
(assert (forall ((bv0 Bool)) (= (set41 bv0) (and (= bv0 true)))))
(assert (let ((a!1 (and (= (sel var_var_h108109 num) 0)
                (forall ((bv0 T641))
                  (= (ilssel var_var_h108109 tbl bv0) (set40 bv0)))
                (not (> 0 (size var_Tbl110)))
                (forall ((bv0 Bool)) (= (mem var_Tbl110 s bv0) (set41 bv0)))))
      (a!2 (=> (forall ((bv0 T641))
                 (= (ilssel var_var_h108109 tbl bv0) (set39 bv0)))
               (forall ((bv0 Bool)) (= (mem var_Tbl111 s bv0) (set38 bv0))))))
  (not (=> a!1 a!2))))

 Show *************** Hoare-Not-Allowed : Now Adding D(ci) Disjuncts ************
Choice 
Show Component fresh_str
 Show **************  Syntactic Equivalent Stuckness Check********fresh_str
 potential Path pp-path  ---> do locbound112 <- apply fresh_str  (

 visited Paths 

 
pp-path  ---> do locbound16 <- apply fresh_str  (

pp-path  ---> do locbound16 <- apply fresh_str  ( ---> do locbound29 <- apply fresh_str  (

pp-path 

Choice 
Show EXPLORED :: pp-path  ---> do locx8 <- [?? : Base {v:Ty_char | true}] ---> do locy9 <- [?? : Base {v:Ty_float | true}] ---> do var_ret7 <- apply create_pair  (, locx8 ), locy9 )

Show ***********Calling weakestPreSynththesis***************