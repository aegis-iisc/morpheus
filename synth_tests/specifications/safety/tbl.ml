tbl : string list ref;



mem : (s  : { v : int | true}) -> (t : {v : tbl | true}) ->  
			State  
			{\(h : heap). true} 
			
			v : { v : bool | true} 
			
			{\(h : heap), (v : bool), (h' : heap). 
				sel (h', tbl) = Tbl' /\ 
				 Tbl' = Tbl
				([v=true] <=> ( mem(Tbl', s) = true))/\ 
				([v=false] <=> (mem (Tbl', s) = false))};

fresh_str : (t : tbl) -> 
			State  {\(h : heap). true} 
			v : { v : string | true} 
			{\(h : heap), (v : string), (h' : heap). 
				len (v) == 3 /\
				sel (h', tbl) = Tbl' /\ 
				mem (Tbl', s) = false};



add : (s : {v : string | true}) ->  (t : {v : tbl | true}) -> 
			State  {\(h : heap).sel (h, tbl) = Tbl /\ 
				(mem (tbl, s) = false)} 
				v : { v : tbl | true} 
			{\(h : heap), (v : tbl), (h' : heap). 
				sel (h', tbl) = Tbl' /\ 
				(mem (Tbl', s) = true) /\ 
				len (Tbl') == len (Tbl) + len (s) /\ 
				size (Tbl') == size (Tbl) + 1};
				


remove 	: (s : {v : int  | true}) ->  (t : {v : tbl | true}) -> 

			State  {\(h : heap).sel (h, tbl) = Tbl /\ 
						(mem (Tbl, s) = true)} 
				v : { v : tbl | true} 
			
			{\(h : heap), (v : unit), (h' : heap). 
				sel (h', tbl) = Tbl' /\ 
				(mem (Tbl', s) = false) /\ 
				len (Tbl') == len (Tbl) - len (s) /\ 
				size (Tbl') == size (Tbl) - 1};

head : (t : {v : tbl | true}) -> 
			State  {\(h : heap).sel (h, tbl) = Tbl 
					/\ size (Tbl) > 0} 
				v : { v : string | true} 
			{\(h : heap), (v : string), (h' : heap). 
				sel (h', tbl) = Tbl' /\ 
				(mem (Tbl', v) = false) /\ 
				len (Tbl') == len (Tbl) - len (v) /\ 
				size (Tbl') == size (Tbl) - 1};



average_len : (t : {v : tbl | true}) -> 
				State  {\(h : heap).
					sel (h, tbl) = Tbl 
					/\ size (Tbl) > 0
					} 
				v : { v : float | true} 
			 {\(h : heap), (v : float), (h' : heap). 
					sel (h', tbl) = Tbl' /\ 
					minmax (v, Tbl') /\
					sel (h', tbl) = sel (h, tbl)};




sort : (t : {v : tbl | true}) -> 
		 State  {\(h : heap). true} 
				v : { v : unit | true} 
			 {\(h : heap), (v : unit), (h' : heap). 
				sel (h, tbl) = Tbl /\ 
				 sorted (Tbl) = true};






goal : (s : {v : string | true}) -> 
		(t : {v : tbl | true}) -> 
		State {\(h : heap). sel (h, tbl) = Tbl}
			v : {v : float | true}
		   
		   {\(h : heap), (v : float), (h' : heap). 
				sel (h', tbl) = Tbl' /\ 
				v >= 0 /\
				minmax (v, Tbl')
				/\ mem (Tbl', s)
				/\ size (Tbl') == size (Tbl) + 2 
			
			};

--------------------------------------------------

goal : string -> tbl -> float



goal : (s : {v : string | true}) -> 
		(t : {v : tbl | true}) -> 
		State {\(h : heap). true}
			v : {v : float | true}
		  {\(h : heap), (v : float), (h' : heap). true};

(*let us try to see the programs which will be generated by the SYPET/H+
With the constraints used in the SYPET that each program variable must be used atleast once.*)


(*generates potentially incorrect program*)
(*synth1*)
\ s tbl. 
(*violating add contract*)
let tbl1 = add_string s tbl in 
let avg = avg_len tbl1 in 
return avg

(*a scenario which will break function*)
let t : tbl = ref []
add t s; 
add_and_take_avg t s 



(*synth2*)
\ s tbl. 
let decision = mem s tbl
if (decision) then 
    let avg = avg_len tbl in 
    return avg;
else 
	(*violating avg_len contract*)
	let avg = avg_len tbl in 
    return avg;

(*a scenario which will break the function*)
let t : tbl = ref []
synth2 t s 



(*synth3 simple programs similar to 1*)
\ s tbl. 
(*a violation*)
let tbl1 = add_string s tbl in 
let s1 = fresh_str tbl1
(*both tbl1 or tbl can  be used as the argument to add_string, by rule Klone*)
(*violation add_string*)
let tbl2 = add_string s1 tbl in 
let avg = avg_len tbl2 in 
return avg

(*synth4*)
\ s tbl. 
(*violation add_contract*)
let tbl1 = add_string s tbl in 
let tbl2 = add_string s tbl in 
let s1 = fresh_str tbl1
(*both tbl1 or tbl can  be used as the argument to add_string, by rule Klone*)
(*violation*)
let tbl2 = add_string s1 tbl in 
let avg = avg_len tbl2 in 
return avg





(*correct programs*)

\s  : string tbl : tbl
let decision = mem s tbl in 
if (decision) then 
	let s1 =  fresh_str tbl in 
	let tbl1 =  add_string s1 tbl in 
	let avg = avg_len tbl1 in 
	return avg;
	
else (*the smallest program*)
	let tbl2 =  add_string s tbl;
	let avg = avg_len tbl2 in 
	return avg;








\s  : string tbl : tbl
let decision = mem s tbl in 
if (decision) then 
	let tbl1 = remove s tbl in 
	let tbl2 =  add_string s1 tbl;
	let avg = avg_len tbl1 in 
	return avg;
	
else (*the smallest program*)
	let tbl2 =  add_string s tbl;
	let avg = avg_len tbl2 in 
	return avg;




(*Not only that, now if the programmer provides richer type specifications for the goal say*)



goal : (s : string) -> (tbl : tbl) -> 
		
		State {true}
			v : float
		   		{
					v >= 0 
		   			/\ minmax (tbl')
					/\ mem (tbl', s)
					/\ size (tbl') == size (tbl) + 2 
			
			};


\s  : string tbl : tbl
let decision = mem s tbl in 
if (decision) then 
	let s1 =  fresh_str tbl in 
	let tbl1 =  add_string s1 tbl in 
	let s2 =  fresh_str tbl in 
	let tbl2 =  add_string s2 tbl1 in 
	let avg = avg_len tbl2 in 
	return avg;
	
else (*the smallest program*)
	let tbl3 =  add_string s tbl;
	let s3 =  fresh_str tbl3 in 
	let tbl4 =  add_string s3 tbl3 in 
	let avg = avg_len tbl4 in 
	return avg;
